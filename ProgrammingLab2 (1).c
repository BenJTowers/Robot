#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor2,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// WHEN YOU FINISH EACH EXERCISE, INCREMENT THIS VALUE
#define EXERCISE_NUMBER 	1

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input


/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released
*/
void monitorInput()
{
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed)
  {
    button2_pushed = true;
  }
}

void exercise_1()
{
	// Define tag for enumerated type for exercise 1
	enum T_exercise1_state {
		Deploy = 0,
		MOTOR_RUNNING
	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.
	T_exercise1_state exercise1_state = Deploy;

	while(true)
	{
		// This function updates the button1_pushed and button2_pushed flags.
		monitorInput();

		// Switch the states.
		switch(exercise1_state) {

			// Code for MOTOR_STOP state:
		case Deploy:
		  while(!button2_pushed){}
			motor[motor1] = -30;
			motor[motor2] = -30;
			if(button1_pushed){
	    exercise1_state = MOTOR_RUNNING;
	   }
			break;
		case MOTOR_RUNNING:
		  motor[motor1] = 0;
			motor[motor2] = 0;
			break;
		default:
		}

	}//end while
}

void exercise_2()
{
	enum T_test_state {
		state1 = 0,
		state2,
		state3
	};

	T_test_state test_state;

  while(true)
  {
    monitorInput();

		  /* INSERT CODE HERE
		  * - Make sure EXERCISE_NUMBER is set to 2
		  */
    }// end while

} // end exercise_2

void exercise_3()
{
		enum T_test_state3 {
		slate1 = 0,
		slate2,
		slate3
	};

	T_test_state3 test_state3 = slate1;

	while(true)
	{
	  monitorInput();
	  switch(test_state3) {
	  	case slate1:
	  	motor[motor1] = 0;
	  	if(button1_pushed){
	  		test_state3 = slate2;
	  		button1_pushed = false;
	  	}
	  	if(button2_pushed){
	  		test_state3 = slate3;
	  		button2_pushed = false;
	  	}
	  break;
	  case slate2:
	  motor[motor1] = 50;
	  	if(getMotorEncoder(motor1) >= 3000){
 			test_state3 = slate1;
 			resetMotorEncoder(motor1);
 		}
 		if(button2_pushed){
 			while(getMotorEncoder(motor1) <= 3000){
 			}
	  		test_state3 = slate3;
	  		resetMotorEncoder(motor1);
	  		button2_pushed = false;
	  	}
	  	break;
	  	  case slate3:
	  motor[motor1] = -50;
	  	if(getMotorEncoder(motor1) <= -3000){
 			test_state3 = slate1;
 			resetMotorEncoder(motor1);
 		}
 		if(button1_pushed){
 			while(getMotorEncoder(motor1) >= -3000){
 			}
	  		test_state3 = slate2;
	  		resetMotorEncoder(motor1);
	  		button1_pushed = false;
	  	}
	  	break;

	  	}





  }//end while

}//end exercse_3

task main()
{
	button1_pushed = button2_pushed = false;

	switch (EXERCISE_NUMBER)
  {
     case 1:
       exercise_1();
       break;
     case 2:
       exercise_2();
       break;
     case 3:
       exercise_3();
       break;
     default: //should never get here.
   } // end switch

}// end main
