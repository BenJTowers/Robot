#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    InfraCollector, sensorReflection)
#pragma config(Sensor, dgtl1,  RedLED1,        sensorDigitalOut)
#pragma config(Sensor, dgtl2,  RedLED2,        sensorNone)
#pragma config(Sensor, dgtl3,  RedLED3,        sensorNone)
#pragma config(Sensor, dgtl6,  button1,        sensorTouch)
#pragma config(Sensor, dgtl7,  button2,        sensorTouch)
#pragma config(Sensor, dgtl8,  lim1,           sensorTouch)
#pragma config(Sensor, dgtl10, sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl12, lim2,           sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           motor3,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const   int IR_SENSOR_THRESHOLD = 110;
// WHEN YOU FINISH EACH EXERCISE, INCREMENT THIS VALUE
#define EXERCISE_NUMBER 	1
bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
int speed = -15;
int distance = 7;

/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released
*/
void monitorInput()
{
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed)
  {
    button2_pushed = true;
  }
}

void exercise_1()
{
	// Define tag for enumerated type for exercise 1
	enum T_exercise1_state {
		RUN,
		TURN,
		MOVE,
		EMERGENCY
	};

	T_exercise1_state exercise1_state = RUN;

	while(true)
	{
		monitorInput();

		switch(exercise1_state) {


		case RUN:
	    int x = SensorValue(sonarSensor);

	    if(x < 0){
			motor[motor1] = -100;
			motor[motor2] = -80;
		}else{
		  int speed = (x-20)*2;
		  motor[motor1] = -speed;
			motor[motor2] = -speed;
		}
		if(x <= 20 && x > 0){
			exercise1_state = TURN;
		}
			break;

			case TURN:
			motor[motor1] = 55;
			motor[motor2] = -55;
		  wait10Msec(300);
		  motor[motor1] = 0;
			motor[motor2] = 0;
		  exercise1_state = RUN;
			break;

			case MOVE:
			resetMotorEncoder(motor1);
			motor[motor1] = 30;
			motor[motor2] = 30;
		 	if (getMotorEncoder(motor1) <= -300) {
			exercise1_state = EMERGENCY;
		}
			if (button2_pushed){
			exercise1_state = EMERGENCY;
		}
			break;

			case EMERGENCY:
			resetMotorEncoder(motor1);
			motor[motor1] = 0;
			motor[motor2] = 0;
			if(button1_pushed){
				exercise1_state = RUN;
				button1_pushed = false;
			break;

		default:
		}

	}
}
}

void exercise_2()
{
	enum T_test_state {
		Bcase = 0,
		Far,
		Meter,
		Close
	};

	T_test_state test_state = Bcase;

  while(true)
  {
    monitorInput();

		 switch(test_state) {

		 case Bcase:
		  SensorValue(RedLED1)= 0;
		  SensorValue(RedLED2)= 0;
		  SensorValue(RedLED3)= 0;
		  int x = 0;
		  if(button1_pushed){
		  	test_state = Far;
		  	button1_pushed = false;
		 }
		  break;

		  case Far:
		  SensorValue(RedLED1)= 1;
		  SensorValue(RedLED2)= 0;
		  SensorValue(RedLED3)= 0;
      x = SensorValue[sonarSensor];
		if(x < 100 && x > 8){
			test_state = Meter;
		}
		if(x < 8){
			test_state = Close;
		  }
		   if(button1_pushed){
		     button1_pushed = false;
		  	test_state = Bcase;
		 }
		  break;

		  case Meter:
		  SensorValue(RedLED2)= 1;
		  SensorValue(RedLED1)= 0;
		  SensorValue(RedLED3)= 0;
		  x = SensorValue[sonarSensor];
		  if(x > 100){
			test_state = Far;
		  }
		  if(x < 8){
			test_state = Close;
		  }
		  if(button1_pushed){
		  	button1_pushed = false;
		  	test_state = Bcase;
		 }
		  break;

		  case Close:
		  SensorValue(RedLED1)= 0;
		  SensorValue(RedLED2)= 0;
		  SensorValue(RedLED3)= 1;
		  x = SensorValue[sonarSensor];
		  if(x > 100){
			test_state = Far;
		  }
		  if(x > 8 && x < 100){
			test_state = Meter;
		}
			if(button1_pushed){
				button1_pushed = false;
		  	test_state = Bcase;
		 }
		  break;

		}
    }// end while

} // end exercise_2

void exercise_3()
{
		enum T_test_state3 {
		slate1 = 0,
		slate2,
		slate3
	};

	T_test_state3 test_state3 = slate1;

	while(true)
	{
	  monitorInput();
	  switch(test_state3) {
	  	case slate1:
	  	if(button1_pushed){
	  		button1_pushed = false;
	  		test_state3 = slate2;
	  	}
	  	break;
	  	case slate2:
	 	 motor[motor3] = -20;
			wait10Msec(105);
			motor[motor3] = 0;
			wait10Msec(200);
			motor[motor3] = 20;
			wait10Msec(100);
			motor[motor3] = 0;
			test_state3 = slate1;
	  break;

	  case slate3:
	  motor[motor1] = 0;
	  motor[motor2] = 0;
	  if(button1_pushed){
	  	test_state3 = slate1;
	  	button1_pushed = false;
	  }
	  	break;


	  	}





  }//end while

}//end exercse_3

task main()
{
	button1_pushed = button2_pushed = false;

	switch (EXERCISE_NUMBER)
  {
     case 1:
       exercise_1();
       break;
     case 2:
       exercise_2();
       break;
     case 3:
       exercise_3();
       break;
     default: //should never get here.
   } // end switch

}// end main
