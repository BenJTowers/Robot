#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    InfraCollector, sensorReflection)
#pragma config(Sensor, dgtl1,  RedLED2,        sensorDigitalOut)
#pragma config(Sensor, dgtl2,  RedLED3,        sensorDigitalOut)
#pragma config(Sensor, dgtl3,  RedLED1,        sensorDigitalOut)
#pragma config(Sensor, dgtl6,  button1,        sensorTouch)
#pragma config(Sensor, dgtl7,  button2,        sensorTouch)
#pragma config(Sensor, dgtl8,  lim1,           sensorTouch)
#pragma config(Sensor, dgtl10, sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl12, lim2,           sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightmotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           leftmotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           motor3,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const   int IR_SENSOR_THRESHOLD = 123;
// WHEN YOU FINISH EACH EXERCISE, INCREMENT THIS VALUE

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
int speedleft = -32;
int speedright = -45;
int distance = 5;
int WallValue = 15;

/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released
*/
void monitorInput()
{
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed)
  {
    button2_pushed = true;
  }
}

void exercise_1()
{
	// Define tag for enumerated type for exercise 1
	enum T_exercise1_state {
		START = 0,
		BCASE,
		WALLCLOSE,
		NONDETECT,
		LIMIT,
		TARGET,
		WITHIN,
		DETECT,
		//APROACH,
		APROACHING,
		DEPLOY,
		VICTORY
	};

	T_exercise1_state exercise1_state = START;

	while(true)
	{
		monitorInput();

		switch(exercise1_state) {

		  case START:
		  SensorValue[RedLED1] = 0;
			SensorValue[RedLED2] = 0;
			SensorValue[RedLED3] = 0;
		  if(button1_pushed){
		  button1_pushed = false;
		  exercise1_state = BCASE;
		 }
		  break;


		  case BCASE:
		  // base case that searches for the sensor
		  if(SensorValue(sonarSensor) <= WallValue){
		  	//senses if the bot is too close to a wall
		  	exercise1_state = WALLCLOSE;
		  }
		  if(SensorValue(lim1) == 1 || SensorValue(lim2) == 1 ){
		  	//senses if the bot hits a limit switch
		  	exercise1_state = WALLCLOSE;
		  }
		  resetMotorEncoder(rightmotor);
		  motor[rightmotor] = 40;
			motor[leftmotor] = -40;
			if(SensorValue[InfraCollector] < IR_SENSOR_THRESHOLD){
			exercise1_state = TARGET;
		  }
		  if(getMotorEncoder(rightmotor) > 1300){
		  	//decides what to do if the sensor doesnt detect light
		  motor[rightmotor] = 0;
			motor[leftmotor] = 0;
		  	exercise1_state = NONDETECT;
		  }
		  if(button2_pushed){
		  	button2_pushed = false;
		  	exercise1_state = START;
		  }

			break;

			case WALLCLOSE:
      //backs up if to close to a wall
			motor[rightmotor] = -speedright;
		  motor[leftmotor] = -speedleft;
		  wait10Msec(150);
		  motor[rightmotor] = 0;
		  motor[leftmotor] = 0;
		  exercise1_state = BCASE;
			break;

			case NONDETECT:
			//heads in the diraction of the furthest wall if no target is sensed
      resetMotorEncoder(rightmotor);
      int direction = 0;
      motor[rightmotor] = 30;
			motor[leftmotor] = -30;
      while(getMotorEncoder(rightmotor) < 1200){
      	if(SensorValue(sonarSensor) > direction){
      		direction = SensorValue(sonarSensor);
       }
        if(button2_pushed){
		  	exercise1_state = START;
		  	button2_pushed = false;
		  }
     }
     resetMotorEncoder(rightmotor);
     while(getMotorEncoder(rightmotor) < 1200){
        if(button2_pushed){
		  	exercise1_state = START;
		  	button2_pushed = false;
		  }
      	if(SensorValue(sonarSensor) > direction-10){
      		resetMotorEncoder(rightmotor);
      		motor[rightmotor] = 0;
					motor[leftmotor] = 0;
					motor[rightmotor] = speedright;
					motor[leftmotor] = speedleft;
					wait10Msec(200);
					motor[rightmotor] = 0;
					motor[leftmotor] = 0;
					exercise1_state = BCASE;
       }
     }
			break;

			case LIMIT:
			//backs up if limit switch is triggered
			motor[rightmotor] = -speedright;
		  motor[leftmotor] = -speedleft;
		  wait10Msec(150);
		  motor[rightmotor] = 0;
		  motor[leftmotor] = 0;
		  exercise1_state = BCASE;
			break;

			case TARGET:
			//has sensed the target and heads towards it until its 60cm away
			SensorValue[RedLED1] = 1;
			int i = 0;
			int prev = 400;
			int cur = 0;
			while(i < 15){
				i++;
				cur = SensorValue[InfraCollector];
				if(cur < prev){
					prev = cur;
				}
			}

			while(SensorValue(sonarSensor) > 60){
			motor[rightmotor] = speedright;
		  motor[leftmotor] = speedleft;
		  }
		  motor[rightmotor] = 0;
		  motor[leftmotor] = 0;
      exercise1_state = WITHIN;

		/*	if(prev > 95){ //subject to change
			motor[rightmotor] = speedright;
		  motor[leftmotor] = speedleft;
		  wait10Msec(250);
		  motor[rightmotor] = 0;
		  motor[leftmotor] = 0;
		  exercise1_state = BCASE;
	  	}
	  	exercise1_state = APROACH; */
			break;

			case WITHIN:
			//moves the sensor away from the target to reasses its location from 60c or less distance
			motor[rightmotor] = -speedright;
		  motor[leftmotor] = speedleft;
		  wait10Msec(150);
		  motor[rightmotor] = 0;
		  motor[leftmotor] = 0;
		  wait10Msec(150);
		  exercise1_state = DETECT;

			break;

			case DETECT:
			//detects the target again more accurately
			motor[rightmotor] = speedright;
		  motor[leftmotor] = -speedleft;
		  if(SensorValue[InfraCollector] < 85){
		  motor[rightmotor] = 0;
		  motor[leftmotor] = 0;
		  wait10Msec(150);
			exercise1_state = APROACHING;
		  }

			break;

		/*	case APROACH:
			SensorValue[RedLED2] = 1;
			motor[rightmotor] = speedright;
		  motor[leftmotor] = speedleft;
		  if(SensorValue[InfraCollector] < 65){//subject to change
		  exercise1_state = APROACHING;
	  	}
			break;*/


			case APROACHING:
			//approaches target until its 6 cm away from the sensor
			SensorValue[RedLED2] = 1;
			motor[rightmotor] = -25;
		  motor[leftmotor] = -15;
			while(SensorValue(sonarSensor) > distance+1){}
			motor[rightmotor] = 0;
		  motor[leftmotor] = 0;
		  exercise1_state = DEPLOY;
			break;

			case DEPLOY:
			//drops the ball
			SensorValue[RedLED3] = 1;
			motor[motor3] = -20;
			wait10Msec(90);
			motor[motor3] = 0;
			wait10Msec(200);
			motor[motor3] = 20;
			wait10Msec(80);
			motor[motor3] = 0;
			wait10Msec(200);
			motor[rightmotor] = -speedright;
		  motor[leftmotor] = -speedleft;
		  wait10Msec(200);
		  motor[rightmotor] = 0;
		  motor[leftmotor] = 0;
			exercise1_state = VICTORY;
			break;

			case VICTORY:
			//victory dance fun parts commented out
			SensorValue[RedLED1] = 1;
			SensorValue[RedLED2] = 0;
			SensorValue[RedLED3] = 1;
			//motor[rightmotor] = speedright;
		  //motor[leftmotor] = -speedleft;
		 // motor[motor3] = -40;
			wait10Msec(25);
			SensorValue[RedLED1] = 0;
			SensorValue[RedLED2] = 1;
			SensorValue[RedLED3] = 0;
		//	motor[rightmotor] = -speedright;
		  //motor[leftmotor] = speedleft;
		 // motor[motor3] = 44;
			wait10Msec(25);
			if(button2_pushed){
		  	exercise1_state = START;
		  	button2_pushed = false;
		  }
			break;

		default:
		}

	}
}




task main()
{
	button1_pushed = button2_pushed = false;


  exercise_1();








}// end main
